---
phase: 01-user-acquisition
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - emrun-frontend/src/services/api.ts
  - emrun-frontend/src/services/auth.service.ts
  - emrun-frontend/contexts/AuthContext.tsx
  - emrun-frontend/app/(auth)/login.tsx
  - emrun-frontend/app/(auth)/register.tsx
  - emrun-frontend/app/_layout.tsx
  - emrun-frontend/src/i18n/locales/fr.json
  - emrun-backend/app/Http/Controllers/Api/AuthController.php
  - emrun-backend/routes/api.php
autonomous: true

must_haves:
  truths:
    - "User can create account with email and password"
    - "User can log in with email and password"
    - "User session persists across app restarts"
    - "User can log out"
    - "Anonymous questionnaire session transfers to user account on signup"
  artifacts:
    - path: "emrun-frontend/src/services/api.ts"
      provides: "Axios instance with JWT interceptors"
      exports: ["api"]
    - path: "emrun-frontend/src/services/auth.service.ts"
      provides: "Auth API calls (login, register, refresh, logout)"
      exports: ["authService"]
    - path: "emrun-frontend/contexts/AuthContext.tsx"
      provides: "Auth state management with secure token storage"
      exports: ["AuthProvider", "useAuth"]
  key_links:
    - from: "emrun-frontend/src/services/api.ts"
      to: "expo-secure-store"
      via: "axios interceptor reads token"
      pattern: "SecureStore\\.getItemAsync"
    - from: "emrun-frontend/src/services/auth.service.ts"
      to: "/api/auth/*"
      via: "HTTP requests"
      pattern: "api\\.post.*auth"
    - from: "emrun-backend/app/Http/Controllers/Api/AuthController.php"
      to: "QuestionnaireSession model"
      via: "session transfer on register"
      pattern: "QuestionnaireSession|sessionId"
---

<objective>
Implement complete authentication flow with secure token storage and anonymous session transfer.

Purpose: Convert anonymous questionnaire users into registered accounts while preserving their data. Secure JWT storage ensures persistent sessions across app restarts.

Output: Working login/register/logout flow with token refresh, and automatic transfer of questionnaire data from anonymous session to user account.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-user-acquisition/01-RESEARCH.md

# Existing files
@emrun-frontend/contexts/AuthContext.tsx
@emrun-frontend/app/(auth)/login.tsx
@emrun-frontend/app/(auth)/register.tsx
@emrun-backend/app/Http/Controllers/Api/AuthController.php
@emrun-backend/routes/api.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API service with JWT interceptors</name>
  <files>
    emrun-frontend/src/services/api.ts
    emrun-frontend/src/services/auth.service.ts
  </files>
  <action>
Create API service (`src/services/api.ts`):
- Create axios instance with baseURL from environment (EXPO_PUBLIC_API_URL)
- Add request interceptor that attaches Bearer token from SecureStore
- Add response interceptor that handles 401 errors with token refresh
- Implement request queuing during token refresh to prevent race conditions
- Use `_retry` flag to prevent infinite refresh loops

```typescript
import axios from 'axios';
import * as SecureStore from 'expo-secure-store';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:8000/api';

export const api = axios.create({
  baseURL: API_URL,
  headers: { 'Content-Type': 'application/json' }
});

// Request interceptor - attach token
api.interceptors.request.use(async (config) => {
  const token = await SecureStore.getItemAsync('accessToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Response interceptor - handle 401 with refresh
let isRefreshing = false;
let failedQueue: Array<{resolve: Function, reject: Function}> = [];

api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        // Queue this request
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        }).then(token => {
          originalRequest.headers.Authorization = `Bearer ${token}`;
          return api(originalRequest);
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        const refreshToken = await SecureStore.getItemAsync('refreshToken');
        const { data } = await axios.post(`${API_URL}/auth/refresh`, { refreshToken });

        await SecureStore.setItemAsync('accessToken', data.accessToken);
        await SecureStore.setItemAsync('refreshToken', data.refreshToken);

        // Retry queued requests
        failedQueue.forEach(({ resolve }) => resolve(data.accessToken));
        failedQueue = [];

        originalRequest.headers.Authorization = `Bearer ${data.accessToken}`;
        return api(originalRequest);
      } catch (refreshError) {
        failedQueue.forEach(({ reject }) => reject(refreshError));
        failedQueue = [];
        // Clear tokens on refresh failure
        await SecureStore.deleteItemAsync('accessToken');
        await SecureStore.deleteItemAsync('refreshToken');
        throw refreshError;
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);
```

Create auth service (`src/services/auth.service.ts`):
- `login(email, password)` - POST /auth/login, store tokens
- `register(email, password, anonymousSessionId)` - POST /auth/register with session transfer
- `logout()` - Clear tokens, optionally call /auth/logout
- `refreshToken()` - POST /auth/refresh
- `getCurrentUser()` - GET /auth/user

All methods should:
- Use the api instance from api.ts
- Handle errors gracefully
- Store/retrieve tokens from SecureStore
- Check token size before storing (2048 byte limit warning)
  </action>
  <verify>
- File `src/services/api.ts` exists with axios instance
- File `src/services/auth.service.ts` exists with login/register/logout functions
- No TypeScript errors: `cd emrun-frontend && npx tsc --noEmit`
  </verify>
  <done>
API service with JWT interceptors and auth service with all auth methods created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AuthContext and update auth screens</name>
  <files>
    emrun-frontend/contexts/AuthContext.tsx
    emrun-frontend/app/(auth)/login.tsx
    emrun-frontend/app/(auth)/register.tsx
    emrun-frontend/app/_layout.tsx
    emrun-frontend/src/i18n/locales/fr.json
  </files>
  <action>
Create/update AuthContext (`contexts/AuthContext.tsx`):
- Provide auth state: `{ user, isLoading, isAuthenticated }`
- Provide auth methods: `{ login, register, logout }`
- Check for stored tokens on app start (restore session)
- Handle loading state while checking stored auth

```typescript
interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (email: string, password: string, sessionId?: string) => Promise<void>;
  logout: () => Promise<void>;
}
```

Update login screen (`app/(auth)/login.tsx`):
- Use React Hook Form for form state
- Use useTranslation for French text
- Call AuthContext login method
- Show loading state during login
- Display error messages in French
- Navigate to dashboard on success
- Link to register screen
- Dark theme styling

Update register screen (`app/(auth)/register.tsx`):
- Use React Hook Form with validation (email format, password min 8 chars)
- Accept anonymousSessionId from route params or QuestionnaireContext
- Call AuthContext register method with session ID
- Show loading state during registration
- Display validation errors in French
- Navigate to subscription flow on success
- Dark theme styling

Add French translations to fr.json:
```json
{
  "auth": {
    "login": {
      "title": "Connexion",
      "email": "Adresse email",
      "password": "Mot de passe",
      "submit": "Se connecter",
      "noAccount": "Pas encore de compte?",
      "register": "Creer un compte"
    },
    "register": {
      "title": "Creer un compte",
      "email": "Adresse email",
      "password": "Mot de passe",
      "confirmPassword": "Confirmer le mot de passe",
      "submit": "S'inscrire",
      "hasAccount": "Deja un compte?",
      "login": "Se connecter"
    },
    "errors": {
      "invalidEmail": "Email invalide",
      "passwordTooShort": "Le mot de passe doit contenir au moins 8 caracteres",
      "passwordMismatch": "Les mots de passe ne correspondent pas",
      "invalidCredentials": "Email ou mot de passe incorrect",
      "emailExists": "Un compte existe deja avec cet email"
    }
  }
}
```

Update root layout (`app/_layout.tsx`):
- Wrap app in AuthProvider
- Check auth state on load
- Redirect to appropriate screen based on auth state
  </action>
  <verify>
- AuthContext exports AuthProvider and useAuth
- Login screen displays in French and accepts input
- Register screen displays in French and accepts input
- App starts without errors: `npx expo start`
  </verify>
  <done>
AuthContext created. Login and register screens updated with French localization and proper form handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Backend session transfer on registration</name>
  <files>
    emrun-backend/app/Http/Controllers/Api/AuthController.php
    emrun-backend/routes/api.php
  </files>
  <action>
Update AuthController (`app/Http/Controllers/Api/AuthController.php`):

Modify the `register` method to:
1. Accept optional `anonymous_session_id` in request
2. Create user account
3. If anonymous_session_id provided:
   - Find QuestionnaireSession by session_id
   - Transfer ownership: update user_id field to new user's ID
   - Optionally copy questionnaire data to UserProfile
4. Generate JWT tokens (access + refresh)
5. Return user data and tokens

```php
public function register(Request $request)
{
    $validated = $request->validate([
        'email' => 'required|email|unique:users',
        'password' => 'required|min:8',
        'anonymous_session_id' => 'nullable|string|uuid'
    ]);

    // Create user
    $user = User::create([
        'email' => $validated['email'],
        'password' => Hash::make($validated['password'])
    ]);

    // Transfer anonymous session if provided
    if (!empty($validated['anonymous_session_id'])) {
        $session = QuestionnaireSession::where('session_id', $validated['anonymous_session_id'])
            ->whereNull('user_id') // Only transfer unclaimed sessions
            ->first();

        if ($session) {
            $session->user_id = $user->id;
            $session->save();

            // Optionally create UserProfile from session data
            UserProfile::create([
                'user_id' => $user->id,
                'questionnaire_data' => $session->data
            ]);
        }
    }

    // Generate tokens
    $accessToken = JWTAuth::fromUser($user);
    $refreshToken = $this->generateRefreshToken($user);

    return response()->json([
        'user' => new UserResource($user),
        'accessToken' => $accessToken,
        'refreshToken' => $refreshToken
    ], 201);
}
```

Verify/update routes (`routes/api.php`):
- POST /auth/register - accepts anonymous_session_id
- POST /auth/login - returns tokens
- POST /auth/refresh - exchanges refresh token
- POST /auth/logout - invalidates tokens (optional)
- GET /auth/user - returns current user (protected)

Ensure refresh token handling:
- Store refresh tokens in database (refresh_tokens table) or use JWT with longer expiry
- Validate refresh token before issuing new access token
- Revoke old refresh token on use (rotation)
  </action>
  <verify>
Test with curl or Postman:
```bash
# Register with session transfer
curl -X POST http://localhost:8000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123","anonymous_session_id":"uuid-here"}'

# Should return user + tokens

# Login
curl -X POST http://localhost:8000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123"}'

# Should return tokens

# Get user (protected)
curl http://localhost:8000/api/auth/user \
  -H "Authorization: Bearer ACCESS_TOKEN_HERE"

# Should return user data
```
  </verify>
  <done>
Backend AuthController updated with anonymous session transfer on registration. Token refresh flow working.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Registration with session transfer test**:
   - Complete questionnaire (creates anonymous session with UUID)
   - Proceed to register screen
   - Register with email/password
   - Verify questionnaire data transferred to new user account (check database)

2. **Login test**:
   - Log out
   - Log in with registered credentials
   - Verify access to protected routes

3. **Session persistence test**:
   - Log in
   - Close and reopen app
   - Verify still logged in (token restored from SecureStore)

4. **Token refresh test**:
   - Log in
   - Wait for access token to expire (or manually expire in backend)
   - Make API request
   - Verify new tokens issued automatically

5. **Logout test**:
   - Click logout
   - Verify redirected to login
   - Verify protected routes inaccessible
</verification>

<success_criteria>
- User can create account with email and password
- User can log in with email and password
- Anonymous session data transfers to user on signup
- Session persists across app restarts
- Token refresh works automatically on 401
- User can log out successfully
- All auth UI displays in French
</success_criteria>

<output>
After completion, create `.planning/phases/01-user-acquisition/01-02-SUMMARY.md`
</output>
